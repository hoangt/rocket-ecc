//Modular multiplication block for ECC

//TODO: Turn this into Montgomery Multiply

package Work{

import Chisel._
import Node._


class modMultiplyIO extends Bundle {
	val control_req_val = Bool(INPUT)
	val control_req_op1 = Bits(INPUT, 256)
	val control_req_op2
	val control_req_modulo = Bits(INPUT, 256)

	val control_resp_val = Bool(OUTPUT)
	val control_resp_data = Bits(OUTPUT, 256)
}

class modMultiply extends Module {
	val io = new modMultiplyIO


	//Registers, using variable notation from McIvor Algorithms 1 and 2
	val op1 = Reg(Bits(0, 256))
	val op2 = Reg(Bits(0, 256))
	val modulo = Reg(Bits(0, 256))

	//Default values of outputs
	io.control_resp_data := Bits(0, 256)

	//For some reason I have to do states this way, Enum isn't working for me, even though I'm doing the exact same things as I did in lab???
	val state = Reg(UInt(0, 3))

	//Valid when you are in the finish state
	//io.control_resp_val := (state === UInt(3))

	//Idle State, grab operands when valid signal goes high
	when(state === UInt(0)){


}

}